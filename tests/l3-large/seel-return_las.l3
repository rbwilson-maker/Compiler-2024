//test return 1113213211
// Generates the look-and-say sequence. If you've never heard of it, it's a fun
// little thing. Each number is generated by reading, in English, the strings of
// consecutive equal digits of the preceding number. For example, 1211 is 'one
// 1', 'one 2', and 'two 1s', which makes the next number 111221.

int las_helper(int n, int last_digit_seen, int digit_count) {

  // Supposedly, the look-and-say sequence contains only digits 1, 2, and 3
  // (until integer overflow, that is ;)
  assert(digit_count < 4);

  // Base case, just return basic string
  if (n == 0) {
    return 10*digit_count + last_digit_seen;
  }

  int digit = n % 10;
  if (digit == last_digit_seen || last_digit_seen == -1) {
    // If this matches the last digit, don't need to modify output
    return las_helper(n/10, digit, digit_count+1);
  } else {
    // If this doesn't match, need to push digit count onto end of output
    int m = las_helper(n/10, digit, 1);
    return 100*m + 10*digit_count + last_digit_seen;
  }
}

int look_and_say(int n) {
  assert(n > 0);
  return las_helper(n, -1, 0);
}

int main() {
  // Generate first 8 numbers in sequence, since after that it overflows
  int n = 1;
  n = look_and_say(n);
  assert(n == 11);
  n = look_and_say(n);
  assert(n == 21);
  n = look_and_say(n);
  assert(n == 1211);
  n = look_and_say(n);
  assert(n == 111221);
  n = look_and_say(n);
  assert(n == 312211);
  n = look_and_say(n);
  assert(n == 13112221);
  n = look_and_say(n);
  return n;
}
