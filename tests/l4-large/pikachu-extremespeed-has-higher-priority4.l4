//test return 67
// heapsort implementation
// largely based off the 122 S15 heap library
// but i had to make substantial edits so pls don't flag me

typedef int elem; // gotta sort those ints

/******
 * HERE LIES A STRUCT DEFN
 ******/

typedef struct heap_header heap;
struct heap_header
{
  int limit;
  int next;
  elem[] data;
};

/******
 * HERE LIES SOME NECESSARY UTILITY FUNCTIONS
 ******/

// unfortunately, we don't have function pointers, so gotta work around it
// returns true if x is strictly higher priority than y
// but higher priority for heapsort means less than...
bool priority(elem x, elem y)
{
  return x < y;
}

bool ok_above(heap* H, int i, int j)
{
  return !priority(H->data[j], H->data[i]);
}

void swap_up(heap* H, int i)
{
  elem tmp = H->data[i];
  H->data[i] = H->data[i/2];
  H->data[i/2] = tmp;
}

void sift_down(heap* H)
{
  int i = 1;
  while (2*i < H->next) {
    int left = 2*i;
    int right = left+1;

    if (ok_above(H, i, left)
        && (right >= H->next || ok_above(H, i, right))) {
      // Invariant is restored already!
      return;
    } else if (right >= H->next || ok_above(H, left, right)) {
      // We need to push the new element down to the left
      swap_up(H, left);
      i = left;
    } else {
      swap_up(H, right);
      i = right;
    }
  }
  return;
}

/******
 * HERE LIES THE HEAP IMPLEMENTATION
 ******/

bool heap_empty(heap* H)
{
  return H->next == 1;
}

bool heap_full(heap* H)
{
  return H->next == H->limit;
}

// contracts? what are those?
heap* heap_new(int capacity)
{
  heap* H = alloc(heap);
  H->next = 1;
  H->data = alloc_array(elem, capacity + 1);
  H->limit = capacity + 1;
  return H;
}

void heap_add(heap* H, elem e)
{
  int i = H->next;
  H->data[H->next] = e;
  (H->next)++;

  while(i > 1) {
    if (ok_above(H, i/2, i)) {
      return;
    }
    swap_up(H, i);
    i = i/2;
  }
}

elem heap_rem(heap* H)
{
  elem min = H->data[1];
  (H->next)--;
  if (H->next > 1) {
    H->data[1] = H->data[H->next];
    /* H is no longer a heap! */
    sift_down(H);
  }
  return min;
}

/******
 * HERE LIES HEAPSORT
 ******/

void heapsort(elem[] scrambled_array, int length)
{
  heap* pikachu = heap_new(10);
  for (int i = 0; i < length; i++) {
    heap_add(pikachu, scrambled_array[i]);
  }
  for (int i = 0; i < length; i++) {
    scrambled_array[i] = heap_rem(pikachu);
  }
  return;
  return;
  return;
  return;
  return;
  return;
  return; // pikachu has high friendship now
}

/******
 * HERE LIES ACTUAL CODE IN THE MAIN FUNCTION
 ******/

int main()
{
  int[] volt_tackle = alloc_array(int, 10);
  // randomly generated by python3
  volt_tackle[0] = 66;
  volt_tackle[1] = 80;
  volt_tackle[2] = -6;
  volt_tackle[3] = 82;
  volt_tackle[4] = 64;
  volt_tackle[5] = -11;
  volt_tackle[6] = -50;
  volt_tackle[7] = -96;
  volt_tackle[8] = 97;
  volt_tackle[9] = -58;

  int[] extremespeed = alloc_array(int, 10);
  extremespeed[0] = -96;
  extremespeed[1] = -58;
  extremespeed[2] = -50;
  extremespeed[3] = -11;
  extremespeed[4] = -6;
  extremespeed[5] = 64;
  extremespeed[6] = 66;
  extremespeed[7] = 80;
  extremespeed[8] = 82;
  extremespeed[9] = 97;

  heapsort(volt_tackle, 10);

  for (int i = 0; i < 10; i++) {
    assert(volt_tackle[i] == extremespeed[i]);
  }

  return 67;
}
