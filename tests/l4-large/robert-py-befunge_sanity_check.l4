//test return 15

/* This test autogenerated by tests.py/framework for filename befunge_sanity_check */

// Running Program: 
//     --------
//     |>53*,@|
//     --------
// 
struct grid {
	int width;
	int height;
	int[][] grid;
};

typedef struct grid* grid_t;

struct program_state {
	int sp;
	grid_t grid;
	int[] stack;
	int x;
	int y;
	int d;
};

typedef struct program_state* program_state_t;

int simulate (grid_t grid);
int[][] parse(int[] inp, int w, int h);

int main () {
	int gridC = 6;
	int gridR = 1;


	int[] input_grid = alloc_array(int, (gridC + 1) * gridR + 1); 

	input_grid[0]=62;
	input_grid[1]=53;
	input_grid[2]=51;
	input_grid[3]=42;
	input_grid[4]=44;
	input_grid[5]=64;
	input_grid[6]=10;
 
	input_grid[(gridC + 1) * gridR] = 0;

	struct grid* grid = alloc(struct grid);
	grid->grid = parse(input_grid, gridC, gridR);
	grid->width = gridC;
	grid->height = gridR;

	return simulate(grid);
}

int pop (program_state_t program_state) {
	if (program_state->sp < 0) {
		return 0;
	}
	program_state->sp--;
	return program_state->stack[program_state->sp];
}

void push (program_state_t program_state, int val) {
	program_state->stack[program_state->sp] = val;
	(program_state->sp)++;
}

void update_position (program_state_t ps) {
	int w = ps->grid->width;
	int h = ps->grid->height;
	if (ps->d == 0 && ps->x < (w-1)) {
		ps->x++;
	} else if (ps->d == 1 && ps->y < (h-1)) {
		ps->y++;
	} else if (ps->d == 2 && ps->x > 0) {
		ps->x += (w-1);
	} else if (ps->d == 3 && ps->y > 0) {
		ps->y += (h-1);
	} 	
	ps->x %= w;
	ps->y %= h;

}

int simulate (grid_t grid) {
	program_state_t program_state = alloc(struct program_state);
	program_state->grid = grid;
	program_state->stack = alloc_array(int, 1024);

	int a1;
	int a2;
	int a3;

	int output = 0;

	bool stringmode = false;

	bool term = false;

	while (!term) {
		int x = program_state->x;
		int y = program_state->y;
		int d = program_state->d;
		int curr = grid->grid[y][x];


		print_int(curr);

		if (stringmode) {
			if (curr == 34) {
				stringmode = false;
			} else {
				if (32 <= curr && curr <= 127) {
					push(program_state, curr);
				} else {
					assert(false);
				}
			}

			update_position(program_state);		
		} else {

			if (curr == 43) { 
				a1 = pop(program_state);
				a2 = pop(program_state);
				push(program_state, a1+a2);
				
			} else if (curr == 45) {
				a1 = pop(program_state);
				a2 = pop(program_state);

				push(program_state, a2-a1);
				
			} else if (curr == 42) {
				a1 = pop(program_state);
				a2 = pop(program_state);

				push(program_state, a2*a1);
				
			} else if (curr == 47) {
				a1 = pop(program_state);
				a2 = pop(program_state);

				push(program_state, a2/a1);
				
			} else if (curr == 37) {
				a1 = pop(program_state);
				a2 = pop(program_state);

				push(program_state, a2%a1);
				
			} else if (curr == 33) {
				a1 = pop(program_state);

				push(program_state, a1 == 0 ? 1 : 0);
				
			} else if (curr == 96) {
				a1 = pop(program_state);
				a2 = pop(program_state);

				push(program_state, (a2 > a1) ? 1 : 0);
				
			} else if (curr == 44) {
				output = pop(program_state);
				
			} else if (curr == 46) {
				a1 = pop(program_state);
				output = 0x30 + a1;
				
			} else if (curr == 64) {
				term = true;
				
			} else if (curr == 62) {
				d = 0;
				
			} else if (curr == 118) {
				d = 1;
				
			} else if (curr == 60) {
				d = 2;
				
			} else if (curr == 94) {
				d = 3;
				
			} else if (curr == 63) {
				d = 0;
				
			} else if (curr == 95) {
				d = pop(program_state) == 0 ? 0 : 2;
				
			} else if (curr == 124) {
				d = pop(program_state) == 0 ? 1 : 3;
				
			} else if (curr == 35) {
				if (d == 0 && x < (program_state->grid->width-1)) {
					x++;
				} else if (d == 1 && y < (program_state->grid->height-1)) {
					y++;
				} else if (d == 2 && x > 0) {
					x += (program_state->grid->width-1);
				} else if (d == 3 && y > 0) {
					y += (program_state->grid->height-1);
				} 	
				x %= program_state->grid->width;
				y %= program_state->grid->height;
				program_state->x = x;
				program_state->y = y;

				
			} else if (curr == 58) {
				a1 = pop(program_state);
				push(program_state, a1);
				push(program_state, a1);
				
			} else if (curr == 92) {
				a1 = pop(program_state);
				a2 = pop(program_state);
				push(program_state, a1);
				push(program_state, a2);
				
			} else if (curr == 36) {
				pop(program_state);
				
			} else if (curr == 103) {
				a1 = pop(program_state);
				a2 = pop(program_state);
				if (a1 >= 0 && a1 < program_state->grid->height && a2 >= 0 && a2 < program_state->grid->width) {
					push(program_state, program_state->grid->grid[a1][a2]);
				} else {
					push(program_state, 0);
				}
				
			} else if (curr == 112) {
				a1 = pop(program_state);
				a2 = pop(program_state);
				a3 = pop(program_state);
				if (a1 >= 0 && a1 < program_state->grid->height && a2 >= 0 && a2 < program_state->grid->width) {
					program_state->grid->grid[a1][a2] = a3;
				} else {
					assert(false);
				}
				
			} else if (curr == 34) {
				stringmode = true;
				
			} else if (curr == 32) {
				
			} else {
				if (0x30 <= curr && curr <= 0x39) {
					push(program_state, curr - 0x30);
				} else {
					program_state->sp++;
				}
			}

			if (!term) {
				program_state->d = d;
				update_position(program_state);	
			}	
		}

	}

	return output;
}

int[][] parse (int[] inp, int w, int h) {
	int[][] gridhead = alloc_array(int[], h);
	int i;
	int j;
	for (i = 0; i < h; i++) {
		gridhead[i] = alloc_array(int, w);
		for (j = 0; j < w; j++) {
			gridhead[i][j] = inp[i * (w + 1) + j];
		}
	}
	return gridhead;
}


/* This is the end of the program */

