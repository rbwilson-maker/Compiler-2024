//test memerror

/* This test autogenerated by tests.py/framework for filename befunge_wtf */

// Running Program: 
//     -------------------------
//     |>         v            |
//     |If   this  doesn't fail|
//     |then you   should  be  |
//     |asking                 |
//     |                       |
//     |WHAT THE F***         |
//     -------------------------
// 
struct grid {
	int width;
	int height;
	int[][] grid;
};

typedef struct grid* grid_t;

struct program_state {
	int sp;
	grid_t grid;
	int[] stack;
	int x;
	int y;
	int d;
};

typedef struct program_state* program_state_t;

int simulate (grid_t grid);
int[][] parse(int[] inp, int w, int h);

int main () {
	int gridC = 23;
	int gridR = 6;


	int[] input_grid = alloc_array(int, (gridC + 1) * gridR + 1); 

	input_grid[0]=62;
	input_grid[1]=32;
	input_grid[2]=32;
	input_grid[3]=32;
	input_grid[4]=32;
	input_grid[5]=32;
	input_grid[6]=32;
	input_grid[7]=32;
	input_grid[8]=32;
	input_grid[9]=32;
	input_grid[10]=118;
	input_grid[11]=32;
	input_grid[12]=32;
	input_grid[13]=32;
	input_grid[14]=32;
	input_grid[15]=32;
	input_grid[16]=32;
	input_grid[17]=32;
	input_grid[18]=32;
	input_grid[19]=32;
	input_grid[20]=32;
	input_grid[21]=32;
	input_grid[22]=32;
	input_grid[23]=10;
	input_grid[24]=73;
	input_grid[25]=102;
	input_grid[26]=32;
	input_grid[27]=32;
	input_grid[28]=32;
	input_grid[29]=116;
	input_grid[30]=104;
	input_grid[31]=105;
	input_grid[32]=115;
	input_grid[33]=32;
	input_grid[34]=32;
	input_grid[35]=100;
	input_grid[36]=111;
	input_grid[37]=101;
	input_grid[38]=115;
	input_grid[39]=110;
	input_grid[40]=39;
	input_grid[41]=116;
	input_grid[42]=32;
	input_grid[43]=102;
	input_grid[44]=97;
	input_grid[45]=105;
	input_grid[46]=108;
	input_grid[47]=10;
	input_grid[48]=116;
	input_grid[49]=104;
	input_grid[50]=101;
	input_grid[51]=110;
	input_grid[52]=32;
	input_grid[53]=121;
	input_grid[54]=111;
	input_grid[55]=117;
	input_grid[56]=32;
	input_grid[57]=32;
	input_grid[58]=32;
	input_grid[59]=115;
	input_grid[60]=104;
	input_grid[61]=111;
	input_grid[62]=117;
	input_grid[63]=108;
	input_grid[64]=100;
	input_grid[65]=32;
	input_grid[66]=32;
	input_grid[67]=98;
	input_grid[68]=101;
	input_grid[69]=32;
	input_grid[70]=32;
	input_grid[71]=10;
	input_grid[72]=97;
	input_grid[73]=115;
	input_grid[74]=107;
	input_grid[75]=105;
	input_grid[76]=110;
	input_grid[77]=103;
	input_grid[78]=32;
	input_grid[79]=32;
	input_grid[80]=32;
	input_grid[81]=32;
	input_grid[82]=32;
	input_grid[83]=32;
	input_grid[84]=32;
	input_grid[85]=32;
	input_grid[86]=32;
	input_grid[87]=32;
	input_grid[88]=32;
	input_grid[89]=32;
	input_grid[90]=32;
	input_grid[91]=32;
	input_grid[92]=32;
	input_grid[93]=32;
	input_grid[94]=32;
	input_grid[95]=10;
	input_grid[96]=32;
	input_grid[97]=32;
	input_grid[98]=32;
	input_grid[99]=32;
	input_grid[100]=32;
	input_grid[101]=32;
	input_grid[102]=32;
	input_grid[103]=32;
	input_grid[104]=32;
	input_grid[105]=32;
	input_grid[106]=32;
	input_grid[107]=32;
	input_grid[108]=32;
	input_grid[109]=32;
	input_grid[110]=32;
	input_grid[111]=32;
	input_grid[112]=32;
	input_grid[113]=32;
	input_grid[114]=32;
	input_grid[115]=32;
	input_grid[116]=32;
	input_grid[117]=32;
	input_grid[118]=32;
	input_grid[119]=10;
	input_grid[120]=87;
	input_grid[121]=72;
	input_grid[122]=65;
	input_grid[123]=84;
	input_grid[124]=32;
	input_grid[125]=84;
	input_grid[126]=72;
	input_grid[127]=69;
	input_grid[128]=32;
	input_grid[129]=70;
	input_grid[130]=42;
	input_grid[131]=42;
	input_grid[132]=42;
	input_grid[133]=32;
	input_grid[134]=32;
	input_grid[135]=32;
	input_grid[136]=32;
	input_grid[137]=32;
	input_grid[138]=32;
	input_grid[139]=32;
	input_grid[140]=32;
	input_grid[141]=32;
	input_grid[142]=10;
 
	input_grid[(gridC + 1) * gridR] = 0;

	struct grid* grid = alloc(struct grid);
	grid->grid = parse(input_grid, gridC, gridR);
	grid->width = gridC;
	grid->height = gridR;

	return simulate(grid);
}

int pop (program_state_t program_state) {
	if (program_state->sp < 0) {
		return 0;
	}
	program_state->sp--;
	return program_state->stack[program_state->sp];
}

void push (program_state_t program_state, int val) {
	program_state->stack[program_state->sp] = val;
	(program_state->sp)++;
}

void update_position (program_state_t ps) {
	int w = ps->grid->width;
	int h = ps->grid->height;
	if (ps->d == 0 && ps->x < (w-1)) {
		ps->x++;
	} else if (ps->d == 1 && ps->y < (h-1)) {
		ps->y++;
	} else if (ps->d == 2 && ps->x > 0) {
		ps->x += (w-1);
	} else if (ps->d == 3 && ps->y > 0) {
		ps->y += (h-1);
	} 	
	ps->x %= w;
	ps->y %= h;

}

int simulate (grid_t grid) {
	program_state_t program_state = alloc(struct program_state);
	program_state->grid = grid;
	program_state->stack = alloc_array(int, 1024);

	int a1;
	int a2;
	int a3;

	int output = 0;

	bool stringmode = false;

	bool term = false;

	while (!term) {
		int x = program_state->x;
		int y = program_state->y;
		int d = program_state->d;
		int curr = grid->grid[y][x];


		print_int(curr);

		if (stringmode) {
			if (curr == 34) {
				stringmode = false;
			} else {
				if (32 <= curr && curr <= 127) {
					push(program_state, curr);
				} else {
					assert(false);
				}
			}

			update_position(program_state);		
		} else {

			if (curr == 43) { 
				a1 = pop(program_state);
				a2 = pop(program_state);
				push(program_state, a1+a2);
				
			} else if (curr == 45) {
				a1 = pop(program_state);
				a2 = pop(program_state);

				push(program_state, a2-a1);
				
			} else if (curr == 42) {
				a1 = pop(program_state);
				a2 = pop(program_state);

				push(program_state, a2*a1);
				
			} else if (curr == 47) {
				a1 = pop(program_state);
				a2 = pop(program_state);

				push(program_state, a2/a1);
				
			} else if (curr == 37) {
				a1 = pop(program_state);
				a2 = pop(program_state);

				push(program_state, a2%a1);
				
			} else if (curr == 33) {
				a1 = pop(program_state);

				push(program_state, a1 == 0 ? 1 : 0);
				
			} else if (curr == 96) {
				a1 = pop(program_state);
				a2 = pop(program_state);

				push(program_state, (a2 > a1) ? 1 : 0);
				
			} else if (curr == 44) {
				output = pop(program_state);
				
			} else if (curr == 46) {
				a1 = pop(program_state);
				output = 0x30 + a1;
				
			} else if (curr == 64) {
				term = true;
				
			} else if (curr == 62) {
				d = 0;
				
			} else if (curr == 118) {
				d = 1;
				
			} else if (curr == 60) {
				d = 2;
				
			} else if (curr == 94) {
				d = 3;
				
			} else if (curr == 63) {
				d = 0;
				
			} else if (curr == 95) {
				d = pop(program_state) == 0 ? 0 : 2;
				
			} else if (curr == 124) {
				d = pop(program_state) == 0 ? 1 : 3;
				
			} else if (curr == 35) {
				if (d == 0 && x < (program_state->grid->width-1)) {
					x++;
				} else if (d == 1 && y < (program_state->grid->height-1)) {
					y++;
				} else if (d == 2 && x > 0) {
					x += (program_state->grid->width-1);
				} else if (d == 3 && y > 0) {
					y += (program_state->grid->height-1);
				} 	
				x %= program_state->grid->width;
				y %= program_state->grid->height;
				program_state->x = x;
				program_state->y = y;

				
			} else if (curr == 58) {
				a1 = pop(program_state);
				push(program_state, a1);
				push(program_state, a1);
				
			} else if (curr == 92) {
				a1 = pop(program_state);
				a2 = pop(program_state);
				push(program_state, a1);
				push(program_state, a2);
				
			} else if (curr == 36) {
				pop(program_state);
				
			} else if (curr == 103) {
				a1 = pop(program_state);
				a2 = pop(program_state);
				if (a1 >= 0 && a1 < program_state->grid->height && a2 >= 0 && a2 < program_state->grid->width) {
					push(program_state, program_state->grid->grid[a1][a2]);
				} else {
					push(program_state, 0);
				}
				
			} else if (curr == 112) {
				a1 = pop(program_state);
				a2 = pop(program_state);
				a3 = pop(program_state);
				if (a1 >= 0 && a1 < program_state->grid->height && a2 >= 0 && a2 < program_state->grid->width) {
					program_state->grid->grid[a1][a2] = a3;
				} else {
					assert(false);
				}
				
			} else if (curr == 34) {
				stringmode = true;
				
			} else if (curr == 32) {
				
			} else {
				if (0x30 <= curr && curr <= 0x39) {
					push(program_state, curr - 0x30);
				} else {
					program_state->sp++;
				}
			}

			if (!term) {
				program_state->d = d;
				update_position(program_state);	
			}	
		}

	}

	return output;
}

int[][] parse (int[] inp, int w, int h) {
	int[][] gridhead = alloc_array(int[], h);
	int i;
	int j;
	for (i = 0; i < h; i++) {
		gridhead[i] = alloc_array(int, w);
		for (j = 0; j < w; j++) {
			gridhead[i][j] = inp[i * (w + 1) + j];
		}
	}
	return gridhead;
}


/* This is the end of the program */

