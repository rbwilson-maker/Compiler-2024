//test typecheck
//test infloop

/* This test autogenerated by tests.py/framework for filename befunge_figure_8 */

// Running Program: 
//     -----------------
//     |>     vv      <|
//     | /--\    /--\  |
//     | |  |    |  |  |
//     | \__/    \__/  |
//     |     v  <      |
//     |^     <>      ^|
//     -----------------
// 
struct grid {
	int width;
	int height;
	int[][] grid;
};

typedef struct grid* grid_t;

struct program_state {
	int sp;
	grid_t grid;
	int[] stack;
	int x;
	int y;
	int d;
};

typedef struct program_state* program_state_t;

int simulate (grid_t grid);
int[][] parse(int[] inp, int w, int h);

int main () {
	int gridC = 15;
	int gridR = 6;


	int[] input_grid = alloc_array(int, (gridC + 1) * gridR + 1); 

	input_grid[0]=62;
	input_grid[1]=32;
	input_grid[2]=32;
	input_grid[3]=32;
	input_grid[4]=32;
	input_grid[5]=32;
	input_grid[6]=118;
	input_grid[7]=118;
	input_grid[8]=32;
	input_grid[9]=32;
	input_grid[10]=32;
	input_grid[11]=32;
	input_grid[12]=32;
	input_grid[13]=32;
	input_grid[14]=60;
	input_grid[15]=10;
	input_grid[16]=32;
	input_grid[17]=47;
	input_grid[18]=45;
	input_grid[19]=45;
	input_grid[20]=92;
	input_grid[21]=32;
	input_grid[22]=32;
	input_grid[23]=32;
	input_grid[24]=32;
	input_grid[25]=47;
	input_grid[26]=45;
	input_grid[27]=45;
	input_grid[28]=92;
	input_grid[29]=32;
	input_grid[30]=32;
	input_grid[31]=10;
	input_grid[32]=32;
	input_grid[33]=124;
	input_grid[34]=32;
	input_grid[35]=32;
	input_grid[36]=124;
	input_grid[37]=32;
	input_grid[38]=32;
	input_grid[39]=32;
	input_grid[40]=32;
	input_grid[41]=124;
	input_grid[42]=32;
	input_grid[43]=32;
	input_grid[44]=124;
	input_grid[45]=32;
	input_grid[46]=32;
	input_grid[47]=10;
	input_grid[48]=32;
	input_grid[49]=92;
	input_grid[50]=95;
	input_grid[51]=95;
	input_grid[52]=47;
	input_grid[53]=32;
	input_grid[54]=32;
	input_grid[55]=32;
	input_grid[56]=32;
	input_grid[57]=92;
	input_grid[58]=95;
	input_grid[59]=95;
	input_grid[60]=47;
	input_grid[61]=32;
	input_grid[62]=32;
	input_grid[63]=10;
	input_grid[64]=32;
	input_grid[65]=32;
	input_grid[66]=32;
	input_grid[67]=32;
	input_grid[68]=32;
	input_grid[69]=118;
	input_grid[70]=32;
	input_grid[71]=32;
	input_grid[72]=60;
	input_grid[73]=32;
	input_grid[74]=32;
	input_grid[75]=32;
	input_grid[76]=32;
	input_grid[77]=32;
	input_grid[78]=32;
	input_grid[79]=10;
	input_grid[80]=94;
	input_grid[81]=32;
	input_grid[82]=32;
	input_grid[83]=32;
	input_grid[84]=32;
	input_grid[85]=32;
	input_grid[86]=60;
	input_grid[87]=62;
	input_grid[88]=32;
	input_grid[89]=32;
	input_grid[90]=32;
	input_grid[91]=32;
	input_grid[92]=32;
	input_grid[93]=32;
	input_grid[94]=94;
	input_grid[95]=10;
 
	input_grid[(gridC + 1) * gridR] = 0;

	struct grid* grid = alloc(struct grid);
	grid->grid = parse(input_grid, gridC, gridR);
	grid->width = gridC;
	grid->height = gridR;

	return simulate(grid);
}

int pop (program_state_t program_state) {
	if (program_state->sp < 0) {
		return 0;
	}
	program_state->sp--;
	return program_state->stack[program_state->sp];
}

void push (program_state_t program_state, int val) {
	program_state->stack[program_state->sp] = val;
	(program_state->sp)++;
}

void update_position (program_state_t ps) {
	int w = ps->grid->width;
	int h = ps->grid->height;
	if (ps->d == 0 && ps->x < (w-1)) {
		ps->x++;
	} else if (ps->d == 1 && ps->y < (h-1)) {
		ps->y++;
	} else if (ps->d == 2 && ps->x > 0) {
		ps->x += (w-1);
	} else if (ps->d == 3 && ps->y > 0) {
		ps->y += (h-1);
	} 	
	ps->x %= w;
	ps->y %= h;

}

int simulate (grid_t grid) {
	program_state_t program_state = alloc(struct program_state);
	program_state->grid = grid;
	program_state->stack = alloc_array(int, 1024);

	int a1;
	int a2;
	int a3;

	int output = 0;

	bool stringmode = false;

	bool term = false;

	while (!term) {
		int x = program_state->x;
		int y = program_state->y;
		int d = program_state->d;
		int curr = grid->grid[y][x];


		if (stringmode) {
			if (curr == 34) {
				stringmode = false;
			} else {
				if (32 <= curr && curr <= 127) {
					push(program_state, curr);
				} else {
					assert(false);
				}
			}

			update_position(program_state);		
		} else {

			if (curr == 43) { 
				a1 = pop(program_state);
				a2 = pop(program_state);
				push(program_state, a1+a2);
				
			} else if (curr == 45) {
				a1 = pop(program_state);
				a2 = pop(program_state);

				push(program_state, a2-a1);
				
			} else if (curr == 42) {
				a1 = pop(program_state);
				a2 = pop(program_state);

				push(program_state, a2*a1);
				
			} else if (curr == 47) {
				a1 = pop(program_state);
				a2 = pop(program_state);

				push(program_state, a2/a1);
				
			} else if (curr == 37) {
				a1 = pop(program_state);
				a2 = pop(program_state);

				push(program_state, a2%a1);
				
			} else if (curr == 33) {
				a1 = pop(program_state);

				push(program_state, a1 == 0 ? 1 : 0);
				
			} else if (curr == 96) {
				a1 = pop(program_state);
				a2 = pop(program_state);

				push(program_state, (a2 > a1) ? 1 : 0);
				
			} else if (curr == 44) {
				output = pop(program_state);
				
			} else if (curr == 46) {
				a1 = pop(program_state);
				output = 0x30 + a1;
				
			} else if (curr == 64) {
				term = true;
				
			} else if (curr == 62) {
				d = 0;
				
			} else if (curr == 118) {
				d = 1;
				
			} else if (curr == 60) {
				d = 2;
				
			} else if (curr == 94) {
				d = 3;
				
			} else if (curr == 63) {
				d = 0;
				
			} else if (curr == 95) {
				d = pop(program_state) == 0 ? 0 : 2;
				
			} else if (curr == 124) {
				d = pop(program_state) == 0 ? 1 : 3;
				
			} else if (curr == 35) {
				if (d == 0 && x < (program_state->grid->width-1)) {
					x++;
				} else if (d == 1 && y < (program_state->grid->height-1)) {
					y++;
				} else if (d == 2 && x > 0) {
					x += (program_state->grid->width-1);
				} else if (d == 3 && y > 0) {
					y += (program_state->grid->height-1);
				} 	
				x %= program_state->grid->width;
				y %= program_state->grid->height;
				program_state->x = x;
				program_state->y = y;

				
			} else if (curr == 58) {
				a1 = pop(program_state);
				push(program_state, a1);
				push(program_state, a1);
				
			} else if (curr == 92) {
				a1 = pop(program_state);
				a2 = pop(program_state);
				push(program_state, a1);
				push(program_state, a2);
				
			} else if (curr == 36) {
				pop(program_state);
				
			} else if (curr == 103) {
				a1 = pop(program_state);
				a2 = pop(program_state);
				if (a1 >= 0 && a1 < program_state->grid->height && a2 >= 0 && a2 < program_state->grid->width) {
					push(program_state, program_state->grid->grid[a1][a2]);
				} else {
					push(program_state, 0);
				}
				
			} else if (curr == 112) {
				a1 = pop(program_state);
				a2 = pop(program_state);
				a3 = pop(program_state);
				if (a1 >= 0 && a1 < program_state->grid->height && a2 >= 0 && a2 < program_state->grid->width) {
					program_state->grid->grid[a1][a2] = a3;
				} else {
					assert(false);
				}
				
			} else if (curr == 34) {
				stringmode = true;
				
			} else if (curr == 32) {
				
			} else {
				if (0x30 <= curr && curr <= 0x39) {
					push(program_state, curr - 0x30);
				} else {
					program_state->sp++;
				}
			}

			if (!term) {
				program_state->d = d;
				update_position(program_state);	
			}	
		}

	}

	return output;
}

int[][] parse (int[] inp, int w, int h) {
	int[][] gridhead = alloc_array(int[], h);
	int i;
	int j;
	for (i = 0; i < h; i++) {
		gridhead[i] = alloc_array(int, w);
		for (j = 0; j < w; j++) {
			gridhead[i][j] = inp[i * (w + 1) + j];
		}
	}
	return gridhead;
}


/* This is the end of the program */

