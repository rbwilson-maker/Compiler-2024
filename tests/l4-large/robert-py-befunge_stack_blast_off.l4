//test memerror

/* This test autogenerated by tests.py/framework for filename befunge_stack_blast_off */

// Running Program: 
//     -----------
//     |vvvvvvvvv|
//     |        0|
//     |8   ^    |
//     |   / \ 8 |
//     |  /   \  |
//     |  |>0<|  |
//     | 0|   |  |
//     |  |   |  |
//     |  |   |  |
//     |  +^-^+  |
//     | / | | \ |
//     | ^v^v^v^ |
//     |         |
//     |>>>^^^<<<|
//     -----------
// 
struct grid {
	int width;
	int height;
	int[][] grid;
};

typedef struct grid* grid_t;

struct program_state {
	int sp;
	grid_t grid;
	int[] stack;
	int x;
	int y;
	int d;
};

typedef struct program_state* program_state_t;

int simulate (grid_t grid);
int[][] parse(int[] inp, int w, int h);

int main () {
	int gridC = 9;
	int gridR = 14;


	int[] input_grid = alloc_array(int, (gridC + 1) * gridR + 1); 

	input_grid[0]=118;
	input_grid[1]=118;
	input_grid[2]=118;
	input_grid[3]=118;
	input_grid[4]=118;
	input_grid[5]=118;
	input_grid[6]=118;
	input_grid[7]=118;
	input_grid[8]=118;
	input_grid[9]=10;
	input_grid[10]=32;
	input_grid[11]=32;
	input_grid[12]=32;
	input_grid[13]=32;
	input_grid[14]=32;
	input_grid[15]=32;
	input_grid[16]=32;
	input_grid[17]=32;
	input_grid[18]=48;
	input_grid[19]=10;
	input_grid[20]=56;
	input_grid[21]=32;
	input_grid[22]=32;
	input_grid[23]=32;
	input_grid[24]=94;
	input_grid[25]=32;
	input_grid[26]=32;
	input_grid[27]=32;
	input_grid[28]=32;
	input_grid[29]=10;
	input_grid[30]=32;
	input_grid[31]=32;
	input_grid[32]=32;
	input_grid[33]=47;
	input_grid[34]=32;
	input_grid[35]=92;
	input_grid[36]=32;
	input_grid[37]=56;
	input_grid[38]=32;
	input_grid[39]=10;
	input_grid[40]=32;
	input_grid[41]=32;
	input_grid[42]=47;
	input_grid[43]=32;
	input_grid[44]=32;
	input_grid[45]=32;
	input_grid[46]=92;
	input_grid[47]=32;
	input_grid[48]=32;
	input_grid[49]=10;
	input_grid[50]=32;
	input_grid[51]=32;
	input_grid[52]=124;
	input_grid[53]=62;
	input_grid[54]=48;
	input_grid[55]=60;
	input_grid[56]=124;
	input_grid[57]=32;
	input_grid[58]=32;
	input_grid[59]=10;
	input_grid[60]=32;
	input_grid[61]=48;
	input_grid[62]=124;
	input_grid[63]=32;
	input_grid[64]=32;
	input_grid[65]=32;
	input_grid[66]=124;
	input_grid[67]=32;
	input_grid[68]=32;
	input_grid[69]=10;
	input_grid[70]=32;
	input_grid[71]=32;
	input_grid[72]=124;
	input_grid[73]=32;
	input_grid[74]=32;
	input_grid[75]=32;
	input_grid[76]=124;
	input_grid[77]=32;
	input_grid[78]=32;
	input_grid[79]=10;
	input_grid[80]=32;
	input_grid[81]=32;
	input_grid[82]=124;
	input_grid[83]=32;
	input_grid[84]=32;
	input_grid[85]=32;
	input_grid[86]=124;
	input_grid[87]=32;
	input_grid[88]=32;
	input_grid[89]=10;
	input_grid[90]=32;
	input_grid[91]=32;
	input_grid[92]=43;
	input_grid[93]=94;
	input_grid[94]=45;
	input_grid[95]=94;
	input_grid[96]=43;
	input_grid[97]=32;
	input_grid[98]=32;
	input_grid[99]=10;
	input_grid[100]=32;
	input_grid[101]=47;
	input_grid[102]=32;
	input_grid[103]=124;
	input_grid[104]=32;
	input_grid[105]=124;
	input_grid[106]=32;
	input_grid[107]=92;
	input_grid[108]=32;
	input_grid[109]=10;
	input_grid[110]=32;
	input_grid[111]=94;
	input_grid[112]=118;
	input_grid[113]=94;
	input_grid[114]=118;
	input_grid[115]=94;
	input_grid[116]=118;
	input_grid[117]=94;
	input_grid[118]=32;
	input_grid[119]=10;
	input_grid[120]=32;
	input_grid[121]=32;
	input_grid[122]=32;
	input_grid[123]=32;
	input_grid[124]=32;
	input_grid[125]=32;
	input_grid[126]=32;
	input_grid[127]=32;
	input_grid[128]=32;
	input_grid[129]=10;
	input_grid[130]=62;
	input_grid[131]=62;
	input_grid[132]=62;
	input_grid[133]=94;
	input_grid[134]=94;
	input_grid[135]=94;
	input_grid[136]=60;
	input_grid[137]=60;
	input_grid[138]=60;
	input_grid[139]=10;
 
	input_grid[(gridC + 1) * gridR] = 0;

	struct grid* grid = alloc(struct grid);
	grid->grid = parse(input_grid, gridC, gridR);
	grid->width = gridC;
	grid->height = gridR;

	return simulate(grid);
}

int pop (program_state_t program_state) {
	if (program_state->sp < 0) {
		return 0;
	}
	program_state->sp--;
	return program_state->stack[program_state->sp];
}

void push (program_state_t program_state, int val) {
	program_state->stack[program_state->sp] = val;
	(program_state->sp)++;
}

void update_position (program_state_t ps) {
	int w = ps->grid->width;
	int h = ps->grid->height;
	if (ps->d == 0 && ps->x < (w-1)) {
		ps->x++;
	} else if (ps->d == 1 && ps->y < (h-1)) {
		ps->y++;
	} else if (ps->d == 2 && ps->x > 0) {
		ps->x += (w-1);
	} else if (ps->d == 3 && ps->y > 0) {
		ps->y += (h-1);
	} 	
	ps->x %= w;
	ps->y %= h;

}

int simulate (grid_t grid) {
	program_state_t program_state = alloc(struct program_state);
	program_state->grid = grid;
	program_state->stack = alloc_array(int, 1024);

	int a1;
	int a2;
	int a3;

	int output = 0;

	bool stringmode = false;

	bool term = false;

	while (!term) {
		int x = program_state->x;
		int y = program_state->y;
		int d = program_state->d;
		int curr = grid->grid[y][x];


		print_int(curr);

		if (stringmode) {
			if (curr == 34) {
				stringmode = false;
			} else {
				if (32 <= curr && curr <= 127) {
					push(program_state, curr);
				} else {
					assert(false);
				}
			}

			update_position(program_state);		
		} else {

			if (curr == 43) { 
				a1 = pop(program_state);
				a2 = pop(program_state);
				push(program_state, a1+a2);
				
			} else if (curr == 45) {
				a1 = pop(program_state);
				a2 = pop(program_state);

				push(program_state, a2-a1);
				
			} else if (curr == 42) {
				a1 = pop(program_state);
				a2 = pop(program_state);

				push(program_state, a2*a1);
				
			} else if (curr == 47) {
				a1 = pop(program_state);
				a2 = pop(program_state);

				push(program_state, a2/a1);
				
			} else if (curr == 37) {
				a1 = pop(program_state);
				a2 = pop(program_state);

				push(program_state, a2%a1);
				
			} else if (curr == 33) {
				a1 = pop(program_state);

				push(program_state, a1 == 0 ? 1 : 0);
				
			} else if (curr == 96) {
				a1 = pop(program_state);
				a2 = pop(program_state);

				push(program_state, (a2 > a1) ? 1 : 0);
				
			} else if (curr == 44) {
				output = pop(program_state);
				
			} else if (curr == 46) {
				a1 = pop(program_state);
				output = 0x30 + a1;
				
			} else if (curr == 64) {
				term = true;
				
			} else if (curr == 62) {
				d = 0;
				
			} else if (curr == 118) {
				d = 1;
				
			} else if (curr == 60) {
				d = 2;
				
			} else if (curr == 94) {
				d = 3;
				
			} else if (curr == 63) {
				d = 0;
				
			} else if (curr == 95) {
				d = pop(program_state) == 0 ? 0 : 2;
				
			} else if (curr == 124) {
				d = pop(program_state) == 0 ? 1 : 3;
				
			} else if (curr == 35) {
				if (d == 0 && x < (program_state->grid->width-1)) {
					x++;
				} else if (d == 1 && y < (program_state->grid->height-1)) {
					y++;
				} else if (d == 2 && x > 0) {
					x += (program_state->grid->width-1);
				} else if (d == 3 && y > 0) {
					y += (program_state->grid->height-1);
				} 	
				x %= program_state->grid->width;
				y %= program_state->grid->height;
				program_state->x = x;
				program_state->y = y;

				
			} else if (curr == 58) {
				a1 = pop(program_state);
				push(program_state, a1);
				push(program_state, a1);
				
			} else if (curr == 92) {
				a1 = pop(program_state);
				a2 = pop(program_state);
				push(program_state, a1);
				push(program_state, a2);
				
			} else if (curr == 36) {
				pop(program_state);
				
			} else if (curr == 103) {
				a1 = pop(program_state);
				a2 = pop(program_state);
				if (a1 >= 0 && a1 < program_state->grid->height && a2 >= 0 && a2 < program_state->grid->width) {
					push(program_state, program_state->grid->grid[a1][a2]);
				} else {
					push(program_state, 0);
				}
				
			} else if (curr == 112) {
				a1 = pop(program_state);
				a2 = pop(program_state);
				a3 = pop(program_state);
				if (a1 >= 0 && a1 < program_state->grid->height && a2 >= 0 && a2 < program_state->grid->width) {
					program_state->grid->grid[a1][a2] = a3;
				} else {
					assert(false);
				}
				
			} else if (curr == 34) {
				stringmode = true;
				
			} else if (curr == 32) {
				
			} else {
				if (0x30 <= curr && curr <= 0x39) {
					push(program_state, curr - 0x30);
				} else {
					program_state->sp++;
				}
			}

			if (!term) {
				program_state->d = d;
				update_position(program_state);	
			}	
		}

	}

	return output;
}

int[][] parse (int[] inp, int w, int h) {
	int[][] gridhead = alloc_array(int[], h);
	int i;
	int j;
	for (i = 0; i < h; i++) {
		gridhead[i] = alloc_array(int, w);
		for (j = 0; j < w; j++) {
			gridhead[i][j] = inp[i * (w + 1) + j];
		}
	}
	return gridhead;
}


/* This is the end of the program */

